# app/main.py
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse, JSONResponse
from datetime import datetime
import ast
import operator as op
import json
import os
from pymongo import MongoClient

# -------------------------
# Config
# -------------------------
app = FastAPI()

# Load MongoDB connection string from Vault file
VAULT_PATH = '/vault/secrets/mongodb'
if not os.path.exists(VAULT_PATH):
    raise RuntimeError(f"Vault secret not found at {VAULT_PATH}")

with open(VAULT_PATH, 'r', encoding='utf-8') as f:
    secret_data = json.load(f)
    MONGODB_URI = secret_data["MONGODB_URI"]

client = MongoClient(MONGODB_URI)
db = client.get_default_database()
calculations = db['calculations']

# -------------------------
# Safe evaluator
# -------------------------
_ALLOWED_OPERATORS = {
    ast.Add: op.add,
    ast.Sub: op.sub,
    ast.Mult: op.mul,
    ast.Div: op.truediv,
    ast.Mod: op.mod,
    ast.Pow: op.pow,
    ast.USub: op.neg,
    ast.UAdd: op.pos,
}

def safe_eval(expr: str):
    if any(c.isalpha() for c in expr):
        raise ValueError('Letters are not allowed in expression')

    try:
        parsed = ast.parse(expr, mode='eval')
    except Exception:
        raise ValueError('Invalid expression')

    def _eval(node):
        if isinstance(node, ast.Expression):
            return _eval(node.body)
        if isinstance(node, ast.Num):
            return node.n
        if hasattr(ast, 'Constant') and isinstance(node, ast.Constant):
            if isinstance(node.value, (int, float)):
                return node.value
            else:
                raise ValueError('Constants other than numbers are not allowed')
        if isinstance(node, ast.BinOp):
            left = _eval(node.left)
            right = _eval(node.right)
            op_type = type(node.op)
            if op_type in _ALLOWED_OPERATORS:
                return _ALLOWED_OPERATORS[op_type](left, right)
            else:
                raise ValueError('Operator not allowed')
        if isinstance(node, ast.UnaryOp):
            operand = _eval(node.operand)
            op_type = type(node.op)
            if op_type in _ALLOWED_OPERATORS:
                return _ALLOWED_OPERATORS[op_type](operand)
            else:
                raise ValueError('Unary operator not allowed')
        if isinstance(node, ast.Call):
            raise ValueError('Function calls are not allowed')
        raise ValueError('Unsupported expression')

    return _eval(parsed)

# -------------------------
# HTML
# -------------------------
INDEX_HTML = """
<!doctype html>
<html lang="pt-br">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Calculadora Flask + MongoDB</title>
    <style>
      body { font-family: Arial, sans-serif; max-width: 720px; margin: 2rem auto; }
      .calc { display:flex; gap:8px; align-items:center; }
      input[type=text] { width: 100%; padding: 8px; font-size: 1rem; }
      button { padding: 8px 12px; font-size: 1rem; }
      .history { margin-top: 1rem; }
      .item { border-bottom: 1px solid #eee; padding: 6px 0; }
      .meta { color: #666; font-size: 0.9rem }
    </style>
  </head>
  <body>
    <h1>Calculadora</h1>

    <div class="calc">
      <input id="expr" type="text" placeholder="Ex: 2+2*3" />
      <button id="calc">Calcular</button>
      <button id="clear">Limpar histórico</button>
    </div>

    <div id="result" style="margin-top:1rem;font-weight:bold"></div>

    <h2>Histórico</h2>
    <div class="history" id="history"></div>

    <script>
      async function refreshHistory() {
        const r = await fetch('/history');
        const data = await r.json();
        const container = document.getElementById('history');
        container.innerHTML = '';
        if (!data.length) {
          container.textContent = 'Nenhum cálculo salvo.';
          return;
        }
        data.forEach(it => {
          const div = document.createElement('div');
          div.className = 'item';
          div.innerHTML = `<div><strong>${it.expression}</strong> = ${it.result}</div><div class="meta">${new Date(it.created_at).toLocaleString()}</div>`;
          container.appendChild(div);
        });
      }

      document.getElementById('calc').addEventListener('click', async () => {
        const expr = document.getElementById('expr').value.trim();
        if (!expr) return;
        const r = await fetch('/calculate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ expression: expr })
        });
        const data = await r.json();
        if (r.status === 200) {
          document.getElementById('result').textContent = `${data.expression} = ${data.result}`;
          document.getElementById('expr').value = '';
          refreshHistory();
        } else {
          document.getElementById('result').textContent = 'Erro: ' + data.error;
        }
      });

      document.getElementById('clear').addEventListener('click', async () => {
        if (!confirm('Remover todo o histórico?')) return;
        const r = await fetch('/history', { method: 'DELETE' });
        if (r.status === 200) refreshHistory();
      });

      refreshHistory();
    </script>
  </body>
</html>
"""
# -------------------------
# Routes
# -------------------------
@app.get("/", response_class=HTMLResponse)
async def index():
    return INDEX_HTML

@app.post("/calculate")
async def calculate(request: Request):
    payload = await request.json()
    expr = (payload.get("expression") or "").strip()
    if not expr:
        return JSONResponse({"error": "Expressão vazia"}, status_code=400)

    try:
        result = safe_eval(expr)
    except Exception as e:
        return JSONResponse({"error": str(e)}, status_code=400)

    doc = {
        "expression": expr,
        "result": str(result),
        "created_at": datetime.utcnow()
    }
    calculations.insert_one(doc)
    doc["_id"] = str(doc.get("_id"))
    return doc

@app.get("/history")
async def get_history():
    items = list(calculations.find().sort("created_at", -1).limit(100))
    for it in items:
        it["_id"] = str(it["_id"])
    return items

@app.delete("/history")
async def delete_history():
    calculations.delete_many({})
    return {"ok": True}

